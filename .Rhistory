<<<<<<< HEAD
=======
tab.names <- apply(expand.grid(dimnames(Nh.tab)),1,paste,collapse="_")
names(Nh.vec) <- tab.names
mosaicplot(Nh.tab)
#sample size
n <- 60 #ceiling(dim(POP)[1]*0.01)
##allocations
#equal
nh.eq <-  rep(n/length(Nh.tab),length(Nh.tab))
names(nh.eq) <- tab.names
#proportional
nh.pr <- round(Nh.tab/sum(Nh.vec)*n)
#optimal
V.h   <- tapply(POP$api99,POP$stype,sd)[tab.names]
nh.op <- round((Nh.tab*V.h)/(sum(Nh.tab*V.h))*n)
##select sample
strSR.sample <- function(strind, nh, replace=FALSE){
Nh   <- table(strind)[names(nh)]
h.id <- split(1:sum(Nh), strind)[names(nh)]
sam <- mapply(function(x,y) sample(x, y, replace=replace), Nh, nh, SIMPLIFY = F)
sam <- unlist(mapply(function(x,y) x[y]
, h.id
, sam, SIMPLIFY = F))
sam
}
R <- 2000
set.seed(4356)
s.eq <- strSR.sample(POP$stype, nh.eq, replace=FALSE)
s.pr <- strSR.sample(POP$stype, nh.pr, replace=FALSE)
s.op <- strSR.sample(POP$stype, nh.op, replace=FALSE)
strSRS.eq <- POP[s.eq,]
strSRS.pr <- POP[s.pr,]
strSRS.op <- POP[s.op,]
#options(survey.lonely.psu="adjust")
svystrSRS.eq <- svydesign(ids=~cds, strata =~stype,  fpc=~Nh, data=strSRS.eq)
svystrSRS.pr <- svydesign(ids=~cds, strata =~stype,  fpc=~Nh, data=strSRS.pr)
svystrSRS.op <- svydesign(ids=~cds, strata =~stype,  fpc=~Nh, data=strSRS.op)
c( eq=SE(svymean(~api00, svystrSRS.eq))
,pr=SE(svymean(~api00, svystrSRS.pr))
,op=SE(svymean(~api00, svystrSRS.op))
)
set.seed(4356)
s.eq <- strSR.sample(POP$stype, nh.eq, replace=FALSE)
s.pr <- strSR.sample(POP$stype, nh.pr, replace=FALSE)
s.op <- strSR.sample(POP$stype, nh.op, replace=FALSE)
strSRS.eq <- POP[s.eq,]
strSRS.pr <- POP[s.pr,]
strSRS.op <- POP[s.op,]
#options(survey.lonely.psu="adjust")
svystrSRS.eq <- svydesign(ids=~cds, strata =~stype,  fpc=~Nh, data=strSRS.eq)
svystrSRS.pr <- svydesign(ids=~cds, strata =~stype,  fpc=~Nh, data=strSRS.pr)
svystrSRS.op <- svydesign(ids=~cds, strata =~stype,  fpc=~Nh, data=strSRS.op)
c( eq=SE(svymean(~api00, svystrSRS.eq))
,pr=SE(svymean(~api00, svystrSRS.pr))
,op=SE(svymean(~api00, svystrSRS.op))
)
svymean(~api00, svystrSRS.eq)
svymean(~api00, svystrSRS.pr)
svymean(~api00, svystrSRS.op)
set.seed(2345)
s.eq <- strSR.sample(POP$stype, nh.eq, replace=FALSE)
s.pr <- strSR.sample(POP$stype, nh.pr, replace=FALSE)
s.op <- strSR.sample(POP$stype, nh.op, replace=FALSE)
strSRS.eq <- POP[s.eq,]
strSRS.pr <- POP[s.pr,]
strSRS.op <- POP[s.op,]
#options(survey.lonely.psu="adjust")
svystrSRS.eq <- svydesign(ids=~cds, strata =~stype,  fpc=~Nh, data=strSRS.eq)
svystrSRS.pr <- svydesign(ids=~cds, strata =~stype,  fpc=~Nh, data=strSRS.pr)
svystrSRS.op <- svydesign(ids=~cds, strata =~stype,  fpc=~Nh, data=strSRS.op)
c( eq=SE(svymean(~api00, svystrSRS.eq))
,pr=SE(svymean(~api00, svystrSRS.pr))
,op=SE(svymean(~api00, svystrSRS.op))
)
set.seed(1133)
s.eq <- strSR.sample(POP$stype, nh.eq, replace=FALSE)
s.pr <- strSR.sample(POP$stype, nh.pr, replace=FALSE)
s.op <- strSR.sample(POP$stype, nh.op, replace=FALSE)
strSRS.eq <- POP[s.eq,]
strSRS.pr <- POP[s.pr,]
strSRS.op <- POP[s.op,]
#options(survey.lonely.psu="adjust")
svystrSRS.eq <- svydesign(ids=~cds, strata =~stype,  fpc=~Nh, data=strSRS.eq)
svystrSRS.pr <- svydesign(ids=~cds, strata =~stype,  fpc=~Nh, data=strSRS.pr)
svystrSRS.op <- svydesign(ids=~cds, strata =~stype,  fpc=~Nh, data=strSRS.op)
c( eq=SE(svymean(~api00, svystrSRS.eq))
,pr=SE(svymean(~api00, svystrSRS.pr))
,op=SE(svymean(~api00, svystrSRS.op))
)
rm(list=ls())
source('~/.active-rstudio-document', echo=TRUE)
)
data(api)
MarginTab  <- table(apipop[,c("stype","sch.wide")])
MarginTab. <- cbind(MarginTab, SUM=rowSums(MarginTab))
MarginTab. <- rbind(MarginTab.,SUM=colSums(MarginTab.))
xtab <- xtable(MarginTab.,digits = 0
,caption = "Population Counts $\\tau_{x_q}$ for School Type (\\texttt{stype}) and School Target (\\texttt{sch.wide}) ")
align(xtab)<- "l|rr|r"
library(PracTools) #load the package
data(smho.N874)    #load the data set
head(smho.N874)
smho <- smho.N874[smho.N874$hosp.type != 4, ]
pairs.chrt <-
ggpairs(smho,columns = which(colnames(smho)%in%c("EXPTOTAL","BEDS","SEENCNT","EOYCNT"))) +
theme(legend.position = "none",
panel.grid.major = element_blank(),
axis.ticks = element_blank(),
axis.title.x = element_text(angle = 90, vjust = 1, color = "black"),
panel.border = element_rect(fill = NA),
axis.text.x =element_text(size=8,angle = 90) )
print(pairs.chrt, left = 0.5, bottom = 0.35)
smho. <- smho
smho.$hosp.type <- as.factor(smho.$hosp.type)
smho.$FINDIRCT  <- as.factor(smho.$FINDIRCT)
lmod1 <- lm(EXPTOTAL ~ SEENCNT + EOYCNT + FINDIRCT + hosp.type:BEDS, data=smho.)
tab.model <- xtable(summary(lmod1),digits = 2,caption = "Model Summary")
print(tab.model,caption.placement = "top")
smho. <-   # before sampling order the data set by hospital type
smho.[order(smho.$hosp.type),]
x <- smho.[,"BEDS"]
x[x <= 5] <- 5      # recode small hospitals to have a minimum size
x <- sqrt(x)
n <- 80             #sample size
IP  <- n*x/sum(x)
set.seed(428274453)
sam <- UPsystematic(IP)
sam.dat <- smho.[sam==1, ]
sam.dat$d <- 1/IP[sam==1] #the design weight
sam.dsgn <-
svydesign(ids = ~1,               # no clusters
strata = NULL,          # no strata
data = sam.dat,         # the sample data
weights = ~d)           # the design weight
#the model we use for the GREG
lmod2 <- lm(EXPTOTAL ~ SEENCNT + EOYCNT + hosp.type:BEDS, data=smho.)
#2. compute pop totals of auxiliaries
pop.tots <- colSums(model.matrix(lmod2)) #Inefficient but convenient!
#3. use 'calibrate' to compute the new weights
sam.cal <-
calibrate(design = sam.dsgn,
formula = ~ SEENCNT + EOYCNT + hosp.type:BEDS,
population = pop.tots,
calfun='linear' )
svytotal(~SEENCNT+EOYCNT, sam.cal)
?smho.N874
svyby(~EXPTOTAL, by=~hosp.type, design=sam.cal, FUN=svytotal)
set.seed(428274453)
sam <- UPsystematic(IP)
sam.dat <- smho.[sam==1, ]
sam.dat$IP <- IP[sam==1]   #the design weight
sam.dsgn <-
svydesign(ids = ~1         # no clusters
,data = sam.dat   # the sample data
,fpc = ~IP        # incl. prob
,pps= "brewer"    # variance approx. method
,variance="YG")   # Variance est. type
sam.dsgn <-
svydesign( ids = ~1         # no clusters
,data = sam.dat   # the sample data
,fpc = ~IP        # incl. prob
,pps= "brewer")    # variance approx. method
lmod2 <- lm(EXPTOTAL ~ SEENCNT + EOYCNT + hosp.type:BEDS, data=smho.)
pop.tots <- colSums(model.matrix(lmod2)) #Inefficient but convenient!
sam.cal <-
calibrate(design = sam.dsgn,
formula = ~ SEENCNT + EOYCNT + hosp.type:BEDS,
population = pop.tots,
calfun='linear' )
e
svyby(~BEDS, by=~hosp.type, design=sam.cal, FUN=svytotal)
svytotal(~SEENCNT+EOYCNT, sam.cal)
pop.tots
svytotal(~EXPTOTAL, sam.cal)
svytotal(~EXPTOTAL, sam.dsgn)
SE(svytotal(~EXPTOTAL, sam.cal))
SE(svytotal(~EXPTOTAL, sam.dsgn))
svytotal(~EXPTOTAL, sam.cal)/svytotal(~EXPTOTAL, sam.dsgn)
svyby(~EXPTOTAL, by=~hosp.type, design=sam.cal, FUN=svytotal)
svyby(~EXPTOTAL, by=~hosp.type, design=sam.dsgn, FUN=svytotal)
pop.tots
tapply(smho.$BEDS,smho.$hosp.type,sum)
table(smho.$hosp.type)
svytotal(~EXPTOTAL, sam.dsgn)
svytotal(~EXPTOTAL, sam.cal)
ori.opt <- options()
options( scipen = 5, digits = 6 )
svytotal(~EXPTOTAL, sam.dsgn)
svytotal(~EXPTOTAL, sam.cal)
options( scipen = 2, digits = 6 )
svytotal(~EXPTOTAL, sam.dsgn)
svytotal(~EXPTOTAL, sam.cal)
options( scipen = 2, digits = 3 )
svytotal(~EXPTOTAL, sam.dsgn)
svytotal(~EXPTOTAL, sam.cal)
options( scipen = 0, digits = 2 )
svytotal(~EXPTOTAL, sam.dsgn)
svytotal(~EXPTOTAL, sam.cal)
options( scipen = 1, digits = 2 )
svytotal(~EXPTOTAL, sam.dsgn)
svytotal(~EXPTOTAL, sam.cal)
options( scipen = 0, digits = 5 )
svytotal(~EXPTOTAL, sam.dsgn)
svytotal(~EXPTOTAL, sam.cal)
options( scipen = 0)
svytotal(~EXPTOTAL, sam.dsgn)
svytotal(~EXPTOTAL, sam.cal)
options( scipen = -1)
svytotal(~EXPTOTAL, sam.dsgn)
svytotal(~EXPTOTAL, sam.cal)
var(svytotal(~EXPTOTAL, sam.dsgn))
SEr(svytotal(~EXPTOTAL, sam.dsgn))
SE(svytotal(~EXPTOTAL, sam.dsgn))
SE(svytotal(~EXPTOTAL, sam.dsgn))^2
vcov(svytotal(~EXPTOTAL, sam.dsgn))
vcov(svytotal(~EXPTOTAL, sam.dsgn))/vcov(svytotal(~EXPTOTAL, sam.cal))
SE(svytotal(~EXPTOTAL, sam.dsgn))/SE(svytotal(~EXPTOTAL, sam.cal))
181.66+51.67
clu <- matrix(1:25 ,ncol=5, byrow=T)
clu.  <- cbind(clu,  rowMeans(clu))
clu.  <- rbind(clu., colMeans(clu.))
clu.  <- rbind(clu., c(apply(clu,2,var),NA))
clu.  <- cbind(clu., c(apply(clu,1,var),NA,var(as.vector(clu) )))
dimnames(clu.) <- list(  c(as.character(c(1:5)),"$\\mu_{.j}$","$V^2_{.j}$")
, c(as.character(c(1:5)),"$\\mu_{i.}$","$V^2_{i.}$"))
clu
clu
SSW.byrow <- sum(apply(clu,1,function(x)sum((x-mean(x))^2)))
SSW.bycol <- sum(apply(clu,2,function(x)sum((x-mean(x))^2)))
delta.byrow <- 1 - (SSW.byrow/(length(clu)-nrow(clu)))/var(as.vector(clu))
delta.bycol <- 1 - (SSW.bycol/(length(clu)-ncol(clu)))/var(as.vector(clu))
deff.byrow <- 1 + (length(clu)-nrow(clu))/(nrow(clu)-1)*delta.byrow
deff.bycol <- 1 + (length(clu)-nrow(clu))/(nrow(clu)-1)*delta.bycol
deffs <- matrix(c(delta.bycol, delta.byrow, deff.bycol, deff.byrow),ncol=2,byrow=T)
deffs
clu.data <- as.vector(clu)
clu.data
rep(1:5,each=5)
rep(1:5,5)
n_I <- 2
n_i <- rep(5,n_I)
n <- sum(n_i)
(n - sum( n_i^2/n, na.rm=TRUE))/(n_I-1)
anova(lm( clu.data ~ psu.col))
psu.col  <- rep(1:5,each=5)
psu.row  <- rep(1:5,5)
anova(lm( clu.data ~ psu.col))[["Mean Sq"]]
MS.row <- anova(lm( clu.data ~ psu.row))[["Mean Sq"]]
MS.row
MS.row
anova(lm( clu.data ~ psu.row))
anova(lm( clu.data ~ psu.row))["Mean Sq"]
MS.col["psu",]
MS.col <- anova(lm( clu.data ~ psu.col))[["Mean Sq"]]
MS.row <- anova(lm( clu.data ~ psu.row))["Mean Sq"]
MS.col["psu",]
MS.col["psu.row",]
MS.col <- anova(lm( clu.data ~ psu.col))["Mean Sq"]
MS.col["psu",]
(MS.col["psu",]-MS.col["Residual",]))
(MS.col["psu",]-MS.col["Residual",])
rho <- (MS.col["psu",]-MS.col["Residual",])/(MS.col["psu",]+(K-1)*MS.col["Residual",])
K <- (n - sum( n_i^2/n, na.rm=TRUE))/(n_I-1)
K <- (n - sum( n_i^2/n))/(n_I-1)
K
(MS.col["psu",]-MS.col["Residual",])/(MS.col["psu",]+(K-1)*MS.col["Residual",])
(MS.row["psu",]-MS.row["Residual",])/(MS.row["psu",]+(K-1)*MS.row["Residual",])
sum(n_i^2)/n
deff.bycol.m <- 1+(b.star - 1)*rho.col
deff.byrow.m <- 1+(b.star - 1)*rho.row
b.star <- sum(n_i^2)/n
deff.bycol.m <- 1+(b.star - 1)*rho.col
deff.byrow.m <- 1+(b.star - 1)*rho.row
rho.col <- (MS.col["psu",]-MS.col["Residual",])/(MS.col["psu",]+(K-1)*MS.col["Residual",])
rho.row <- (MS.row["psu",]-MS.row["Residual",])/(MS.row["psu",]+(K-1)*MS.row["Residual",])
deff.bycol.m <- 1+(b.star - 1)*rho.col
deff.byrow.m <- 1+(b.star - 1)*rho.row
deff.bycol.m
deff.byrow.m
deffs <- matrix(c(rho.col, delta.bycol.m, rho.row, deff.byrow.m),ncol=2)
deff.bycol.m <- 1+(b.star - 1)*rho.col
deff.byrow.m <- 1+(b.star - 1)*rho.row
deffs <- matrix(c(rho.col, delta.bycol.m, rho.row, deff.byrow.m),ncol=2)
deffs <- matrix(c(rho.col, deff.bycol.m, rho.row, deff.byrow.m),ncol=2)
deffs
1+(b.star - 1)*rho.col
1+(b.star - 1)*rho.row
rho.col
rho.row
SSW.byrow <- sum(apply(clu,1,function(x)sum((x-mean(x))^2)))
SSW.bycol <- sum(apply(clu,2,function(x)sum((x-mean(x))^2)))
delta.byrow <- 1 - (SSW.byrow/(length(clu)-nrow(clu)))/var(as.vector(clu))
delta.bycol <- 1 - (SSW.bycol/(length(clu)-ncol(clu)))/var(as.vector(clu))
delta.byrow
delta.bycol
clu.data <- as.vector(clu)
psu.col  <- rep(1:5,each=5)
psu.row  <- rep(1:5,5)
n_I <- 2
n_i <- rep(5,n_I)
n <- sum(n_i)
K <- (n - sum( n_i^2/n))/(n_I-1)
b.star <- sum(n_i^2)/n
MS.col <- anova(lm( clu.data ~ psu.col))["Mean Sq"]
MS.row <- anova(lm( clu.data ~ psu.row))["Mean Sq"]
rho.col <- (MS.col["psu",]-MS.col["Residual",])/(MS.col["psu",]+(K-1)*MS.col["Residual",])
rho.row <- (MS.row["psu",]-MS.row["Residual",])/(MS.row["psu",]+(K-1)*MS.row["Residual",])
deff.bycol.m <- 1+(b.star - 1)*rho.col
deff.byrow.m <- 1+(b.star - 1)*rho.row
deffs <- matrix(c(rho.col, deff.bycol.m, rho.row, deff.byrow.m),ncol=2)
dimnames(deffs) <-
list(c("$\\rho$","$\\deff$"), c("SRCS a", "SRCS b"))
clu.data <- as.vector(clu)
psu.col  <- rep(1:5,each=5)
psu.row  <- rep(1:5,5)
n_I <- 2
n_i <- rep(5,n_I)
n <- sum(n_i)
K <- (n - sum( n_i^2/n))/(n_I-1)
b.star <- sum(n_i^2)/n
MS.col <- anova(lm( clu.data ~ psu.col))["Mean Sq"]
MS.row <- anova(lm( clu.data ~ psu.row))["Mean Sq"]
rho.col <- (MS.col["psu",]-MS.col["Residual",])/(MS.col["psu",]+(K-1)*MS.col["Residual",])
rho.row <- (MS.row["psu",]-MS.row["Residual",])/(MS.row["psu",]+(K-1)*MS.row["Residual",])
deff.bycol.m <- 1+(b.star - 1)*rho.col
deff.byrow.m <- 1+(b.star - 1)*rho.row
deffm <- matrix(c(rho.col, deff.bycol.m, rho.row, deff.byrow.m),ncol=2)
dimnames(deffm) <-
list(c("$\\rho$","$\\deff$"), c("SRCS a", "SRCS b"))
deffm.tab <- xtable(deffm, digits = 5, caption = "Intra-Class Correlation Coefficient and Design Effects")
align(deffm.tab ) <- "l|rr"
print.xtable(deffm.tab, hline.after = 0,  caption.placement="top", sanitize.text.function = identity)
library(xtable)
clu.data <- as.vector(clu)
psu.col  <- rep(1:5,each=5)
psu.row  <- rep(1:5,5)
n_I <- 2
n_i <- rep(5,n_I)
n <- sum(n_i)
K <- (n - sum( n_i^2/n))/(n_I-1)
b.star <- sum(n_i^2)/n
MS.col <- anova(lm( clu.data ~ psu.col))["Mean Sq"]
MS.row <- anova(lm( clu.data ~ psu.row))["Mean Sq"]
rho.col <- (MS.col["psu",]-MS.col["Residual",])/(MS.col["psu",]+(K-1)*MS.col["Residual",])
rho.row <- (MS.row["psu",]-MS.row["Residual",])/(MS.row["psu",]+(K-1)*MS.row["Residual",])
deff.bycol.m <- 1+(b.star - 1)*rho.col
deff.byrow.m <- 1+(b.star - 1)*rho.row
deffm <- matrix(c(rho.col, deff.bycol.m, rho.row, deff.byrow.m),ncol=2)
dimnames(deffm) <-
list(c("$\\rho$","$\\deff$"), c("SRCS a", "SRCS b"))
deffm.tab <- xtable(deffm, digits = 5, caption = "Intra-Class Correlation Coefficient and Design Effects")
align(deffm.tab ) <- "l|rr"
print.xtable(deffm.tab, hline.after = 0,  caption.placement="top", sanitize.text.function = identity)
clu.data <- as.vector(clu)
psu.col  <- rep(1:5,each=5)
psu.row  <- rep(1:5,5)
n_I <- 2
n_i <- rep(5,n_I)
n <- sum(n_i)
K <- (n - sum( n_i^2/n))/(n_I-1)
b.star <- sum(n_i^2)/n
MS.col <- anova(lm( clu.data ~ psu.col))["Mean Sq"]
MS.row <- anova(lm( clu.data ~ psu.row))["Mean Sq"]
rho.col <- (MS.col["psu",]-MS.col["Residual",])/(MS.col["psu",]+(K-1)*MS.col["Residual",])
rho.row <- (MS.row["psu",]-MS.row["Residual",])/(MS.row["psu",]+(K-1)*MS.row["Residual",])
deff.bycol.m <- 1+(b.star - 1)*rho.col
deff.byrow.m <- 1+(b.star - 1)*rho.row
deffm <- matrix(c(rho.col, deff.bycol.m, rho.row, deff.byrow.m),ncol=2)
dimnames(deffm) <-
list(c("$\\rho$","$\\deff$"), c("SRCS a", "SRCS b"))
deffm.tab <- xtable(deffm, digits = 5, caption = "Intra-Class Correlation Coefficient and (Model) Design Effects")
align(deffm.tab ) <- "l|rr"
print.xtable(deffm.tab, hline.after = 0,  caption.placement="top", sanitize.text.function = identity)
print.xtable(deffs.tab, hline.after = 0,  caption.placement="top", sanitize.text.function = identity)
print.xtable(deffs.tab, hline.after = 0,  caption.placement="top", sanitize.text.function = identity)
@
print.xtable(deffs.tab, hline.after = 0,  caption.placement="top", sanitize.text.function = identity)
SSW.byrow <- sum(apply(clu,1,function(x)sum((x-mean(x))^2)))
SSW.bycol <- sum(apply(clu,2,function(x)sum((x-mean(x))^2)))
delta.byrow <- 1 - (SSW.byrow/(length(clu)-nrow(clu)))/var(as.vector(clu))
delta.bycol <- 1 - (SSW.bycol/(length(clu)-ncol(clu)))/var(as.vector(clu))
deff.byrow <- 1 + (length(clu)-nrow(clu))/(nrow(clu)-1)*delta.byrow
deff.bycol <- 1 + (length(clu)-nrow(clu))/(nrow(clu)-1)*delta.bycol
deffs <- matrix(c(delta.bycol, delta.byrow, deff.bycol, deff.byrow),ncol=2,byrow=T)
dimnames(deffs) <-
list(c("$\\delta$","$\\deff$"), c("SRCS a", "SRCS b"))
deffs.tab <- xtable(deffs, digits = 5, caption = "Intra-Cluster Homogeneity and Design Effects")
align(deffs.tab ) <- "l|rr"
print.xtable(clu.tab,hline.after = c(0,5,6),caption.placement="top", sanitize.text.function = identity)
print.xtable(deffs.tab, hline.after = 0,  caption.placement="top", sanitize.text.function = identity)
SSW.byrow <- sum(apply(clu,1,function(x)sum((x-mean(x))^2)))
SSW.bycol <- sum(apply(clu,2,function(x)sum((x-mean(x))^2)))
delta.byrow <- 1 - (SSW.byrow/(length(clu)-nrow(clu)))/var(as.vector(clu))
delta.bycol <- 1 - (SSW.bycol/(length(clu)-ncol(clu)))/var(as.vector(clu))
deff.byrow <- 1 + (length(clu)-nrow(clu))/(nrow(clu)-1)*delta.byrow
deff.bycol <- 1 + (length(clu)-nrow(clu))/(nrow(clu)-1)*delta.bycol
deffs <- matrix(c(delta.bycol, delta.byrow, deff.bycol, deff.byrow),ncol=2,byrow=T)
dimnames(deffs) <-
list(c("$\\delta$","$\\deff$"), c("SRCS a", "SRCS b"))
deffs.tab <- xtable(deffs, digits = 5, caption = "Intra-Cluster Homogeneity and Design Effects")
align(deffs.tab ) <- "l|rr"
print.xtable(clu.tab,hline.after = c(0,5,6),caption.placement="top", sanitize.text.function = identity)
print.xtable(deffs.tab, hline.after = 0,  caption.placement="top", sanitize.text.function = identity)
clu.data <- as.vector(clu)
psu.col  <- rep(1:5,each=5)
psu.row  <- rep(1:5,5)
n_I <- 2
n_i <- rep(5,n_I)
n <- sum(n_i)
K <- (n - sum( n_i^2/n))/(n_I-1)
b.star <- sum(n_i^2)/n
MS.col <- anova(lm( clu.data ~ psu.col))["Mean Sq"]
MS.row <- anova(lm( clu.data ~ psu.row))["Mean Sq"]
rho.col <- (MS.col["psu",]-MS.col["Residual",])/(MS.col["psu",]+(K-1)*MS.col["Residual",])
rho.row <- (MS.row["psu",]-MS.row["Residual",])/(MS.row["psu",]+(K-1)*MS.row["Residual",])
deff.bycol.m <- 1+(b.star - 1)*rho.col
deff.byrow.m <- 1+(b.star - 1)*rho.row
deffm <- matrix(c(rho.col, deff.bycol.m, rho.row, deff.byrow.m),ncol=2)
dimnames(deffm) <-
list(c("$\\rho$","$\\deff$"), c("SRCS a", "SRCS b"))
deffm.tab <- xtable(deffm, digits = 5, caption = "Intra-Class Correlation Coefficient and (Model) Design Effects")
align(deffm.tab ) <- "l|rr"
print.xtable(deffm.tab, hline.after = 0,  caption.placement="top", sanitize.text.function = identity)
print.xtable(deffs.tab, hline.after = 0,  caption.placement="top", sanitize.text.function = identity)
deffs[-1,]
xtable(deffs[-1,], digits = 5, caption = "Intra-Cluster Homogeneity and Design Effects")
class(deffs[-1,])
class(deffs)
deffs.tab <- xtable(deffs[-1,,drop=F], digits = 5, caption = "Intra-Cluster Homogeneity and Design Effects")
deffs.tab
library(survey)
library(sampling)
strSR.sample <- function(strind, nh, replace=FALSE){
Nh   <- table(strind)[names(nh)]
h.id <- split(1:sum(Nh), strind)[names(nh)]
sam <- mapply(function(x,y) sample(x, y, replace=replace), Nh, nh, SIMPLIFY = F)
sam <- unlist(mapply(function(x,y) x[y]
, h.id
, sam, SIMPLIFY = F))
sam
}
data(api)
POP <- apipop
POP$qapi99    <- cut(POP$api99, quantile(POP$api99), include.lowest = T)
POP$Nh        <- table(POP$stype)[POP$stype]
Nh.tab        <- table(POP$stype)
Nh.vec        <- as.vector(Nh)
clu
source('~/.active-rstudio-document', echo=TRUE)
clu
clu
ncol(clu)^2/N^2 * (1-n_I/ncol(clu))*var(apply(clu,2,sum))/n_I
(1-n/N)*var(as.vector(clu))/n}
(1-n/N)*var(as.vector(clu))/n}
(1-n/N)*var(as.vector(clu))/n
clu
N
R <- 100000  #number samples
n   <- 10
n_I <- 2
N   <- length(clu)
(1-n/N)*var(as.vector(clu))/n
ncol(clu)^2/N^2 * (1-n_I/ncol(clu))*var(apply(clu,2,sum))/n_I
0.75/3.25
nrow(clu)^2/N^2 * (1-n_I/nrow(clu))*var(apply(clu,1,sum))/n_I
0.75/18.75
18.75/3.25
ncol(clu)^2/N^2 * (1-n_I/ncol(clu))*var(apply(clu,2,sum))/n_I
SRS.var      <- (1-n/N)*var(as.vector(clu))/n
SRcS.var.col <- ncol(clu)^2/N^2 * (1-n_I/ncol(clu))*var(apply(clu,2,sum))/n_I
SRcS.var.row <- ncol(clu)^2/N^2 * (1-n_I/ncol(clu))*var(apply(clu,1,sum))/n_I
SRS.var
SRcS.var.col
SRcS.var.row
apipop$cds
lmod <- lm(as.numeric(apipop$cds) ~ stype:api99, data=apipop$cds)
as.numeric(apipop$cds)
lmod <- lm(as.numeric(apipop$cds) ~ stype:api99, data=apipop)
data(api)
library(survey)
data(api)
svy_api <- svydesign(id=~1,strata=~stype,
fpc=~fpc, data=apistrat)
lmod <- lm(1:nrow(apipop) ~ stype:api99, data=apipop)
pop.tots <- colSums(model.matrix(lmod2))
pop.tots <- colSums(model.matrix(lmod))
svy_api.cal <-
calibrate(design = svy_api,
formula = ~ stype:api99,
population = pop.tots,
calfun='linear' )
svymean(~api00, svy_api)
svymean(~api00, svy_api.cal)
pop.tots
2*1.96*0.025
0.05/(2*1.96)
getwd()
7.54*2
7.54*2.5
7.54*5
7.54*5*4
39.5*4
15.08/158
7.54*2.5
(7.54*2.5)/158
0.1/2
(7.54*3)/158
(7.54*4)/158
(7.54*5)/158
(7.54*4.5)/158
(7.54*4.1)/158
The authors addressed almost all of the issues raised in the first review and their response if mostly satisfying.
429.30+25+150
>>>>>>> 4a5c98796c7e3d9b11dcc259c694697e9d1ad0a5

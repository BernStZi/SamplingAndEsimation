<<<<<<< HEAD
install.packages("alabama")
install.packages("PracTools")
5862+2974+1619+561+467+196+163
4806+2394+1267+450+404+161+131
2617*.684
2617-1790
48.5+5.4
34.7+1.8
31169+5195+3306+3967+11563+22105+10316+15474
11132+1855+1181+1416+4216+7895+3684+5526
14000+7000+14000+13999
3684+1842+3684+3683
600*.6
1200/21
library(knitr)
Sweave2knitr("Ex1.Rnw")
Sweave2knitr("H:/Sand_Summerschool/SamplingAndEsimation/tutorial/Exercises/Exercise1/x1.Rnw")
Sweave2knitr("H:/Sand_Summerschool/SamplingAndEsimation/tutorial/Exercises/Exercise1/Ex1.Rnw")
library(survey)
data(api)
View(apisrs)
library(foreign)
library(survey)
path <- "F:/ESS Data/"
path.ger <- "F:/ESS Data/Germany/"
path.net <- "F:/ESS Data/Netherlands/"
setwd(path)
#### Germany ####
Ger.d <- read.spss(paste(path.ger,"ESS5DE.spss/ESS5DE.sav",sep=""),to.data.frame = TRUE)
Ger.ctry <- read.spss(paste(path.ger,"ESS5_DE_SDDF.spss/ESS5_DE_SDDF.por",sep=""),to.data.frame = TRUE, use.value.labels = TRUE)
colnames(Ger.d)[5] <- "IDNO"
Ger <- merge(Ger.d,Ger.ctry,by="IDNO", all.x = TRUE)
Ger$PSU <- as.factor(Ger$PSU)
n <- nrow(Ger)
L <- length(unique(Ger$PSU))
## deffp
df.tab <- as.data.frame(table(Ger$PSU,Ger$dweight))
head(deff.tab)
deff.tab <- subset(df.tab,df.tab[,3]!=0)
deff.tab[,2] <- as.numeric(as.character(deff.tab[,2]))
deff_p <- n*sum(deff.tab[,3]*deff.tab[,2]^2)/(sum(deff.tab[,3]*deff.tab[,2])^2)
## deffc
b <- sum(tapply(Ger$dweight,Ger$PSU,function(x)sum(x)^2))/sum(Ger$dweight^2)
SS <- anova(lm(as.numeric(Ger$agea)~Ger$PSU))
MSB <- SS$`Mean Sq`[1]
MSW <- SS$`Mean Sq`[2]
K <- 1/(L-1)*(n-sum(deff.tab[,3]^2/n))
rho <- (MSB-MSW)/(MSB+(K-1)*MSW)
deff_c <- 1+(b-1)*rho
## deff
deff <- deff_p*deff_c
deff
View(SS)
neff <- nrow(Ger)/deff
neff
library("knitr", lib.loc="~/R/win-library/3.1")
Sweave2knitr(Day1.Rnw)
Sweave2knitr("H:/Sand_Summerschool/SamplingAndEsimation/tutorial/slides/Part1/Day1.Rnw")
=======
s.op <- strSR.sample(POP$stype, nh.op, replace=FALSE)
strSRS.eq <- POP[s.eq,]
strSRS.pr <- POP[s.pr,]
strSRS.op <- POP[s.op,]
#options(survey.lonely.psu="adjust")
svystrSRS.eq <- svydesign(ids=~cds, strata =~strind,  fpc=~Nh, data=strSRS.eq)
svystrSRS.pr <- svydesign(ids=~cds, strata =~strind,  fpc=~Nh, data=strSRS.pr)
svystrSRS.op <- svydesign(ids=~cds, strata =~strind,  fpc=~Nh, data=strSRS.op)
svymean(~api00, svystrSRS.eq)
svymean(~api00, svystrSRS.pr)
svymean(~api00, svystrSRS.op)
s.eq <- strSR.sample(POP$stype, nh.eq, replace=FALSE)
s.pr <- strSR.sample(POP$stype, nh.pr, replace=FALSE)
s.op <- strSR.sample(POP$stype, nh.op, replace=FALSE)
strSRS.eq <- POP[s.eq,]
strSRS.pr <- POP[s.pr,]
strSRS.op <- POP[s.op,]
#options(survey.lonely.psu="adjust")
svystrSRS.eq <- svydesign(ids=~cds, strata =~strind,  fpc=~Nh, data=strSRS.eq)
svystrSRS.pr <- svydesign(ids=~cds, strata =~strind,  fpc=~Nh, data=strSRS.pr)
svystrSRS.op <- svydesign(ids=~cds, strata =~strind,  fpc=~Nh, data=strSRS.op)
c( eq=SE(svymean(~api00, svystrSRS.eq))
,pr=SE(svymean(~api00, svystrSRS.pr))
,op=SE(svymean(~api00, svystrSRS.op))
)
set.seed(5467)
s.eq <- strSR.sample(POP$stype, nh.eq, replace=FALSE)
s.pr <- strSR.sample(POP$stype, nh.pr, replace=FALSE)
s.op <- strSR.sample(POP$stype, nh.op, replace=FALSE)
strSRS.eq <- POP[s.eq,]
strSRS.pr <- POP[s.pr,]
strSRS.op <- POP[s.op,]
#options(survey.lonely.psu="adjust")
svystrSRS.eq <- svydesign(ids=~cds, strata =~strind,  fpc=~Nh, data=strSRS.eq)
svystrSRS.pr <- svydesign(ids=~cds, strata =~strind,  fpc=~Nh, data=strSRS.pr)
svystrSRS.op <- svydesign(ids=~cds, strata =~strind,  fpc=~Nh, data=strSRS.op)
c( eq=SE(svymean(~api00, svystrSRS.eq))
,pr=SE(svymean(~api00, svystrSRS.pr))
,op=SE(svymean(~api00, svystrSRS.op))
)
set.seed(4567)
s.eq <- strSR.sample(POP$stype, nh.eq, replace=FALSE)
s.pr <- strSR.sample(POP$stype, nh.pr, replace=FALSE)
s.op <- strSR.sample(POP$stype, nh.op, replace=FALSE)
strSRS.eq <- POP[s.eq,]
strSRS.pr <- POP[s.pr,]
strSRS.op <- POP[s.op,]
#options(survey.lonely.psu="adjust")
svystrSRS.eq <- svydesign(ids=~cds, strata =~strind,  fpc=~Nh, data=strSRS.eq)
svystrSRS.pr <- svydesign(ids=~cds, strata =~strind,  fpc=~Nh, data=strSRS.pr)
svystrSRS.op <- svydesign(ids=~cds, strata =~strind,  fpc=~Nh, data=strSRS.op)
c( eq=SE(svymean(~api00, svystrSRS.eq))
,pr=SE(svymean(~api00, svystrSRS.pr))
,op=SE(svymean(~api00, svystrSRS.op))
)
set.seed(458)
s.eq <- strSR.sample(POP$stype, nh.eq, replace=FALSE)
s.pr <- strSR.sample(POP$stype, nh.pr, replace=FALSE)
s.op <- strSR.sample(POP$stype, nh.op, replace=FALSE)
strSRS.eq <- POP[s.eq,]
strSRS.pr <- POP[s.pr,]
strSRS.op <- POP[s.op,]
#options(survey.lonely.psu="adjust")
svystrSRS.eq <- svydesign(ids=~cds, strata =~strind,  fpc=~Nh, data=strSRS.eq)
svystrSRS.pr <- svydesign(ids=~cds, strata =~strind,  fpc=~Nh, data=strSRS.pr)
svystrSRS.op <- svydesign(ids=~cds, strata =~strind,  fpc=~Nh, data=strSRS.op)
c( eq=SE(svymean(~api00, svystrSRS.eq))
,pr=SE(svymean(~api00, svystrSRS.pr))
,op=SE(svymean(~api00, svystrSRS.op))
)
set.seed(436)
s.eq <- strSR.sample(POP$stype, nh.eq, replace=FALSE)
s.pr <- strSR.sample(POP$stype, nh.pr, replace=FALSE)
s.op <- strSR.sample(POP$stype, nh.op, replace=FALSE)
strSRS.eq <- POP[s.eq,]
strSRS.pr <- POP[s.pr,]
strSRS.op <- POP[s.op,]
#options(survey.lonely.psu="adjust")
svystrSRS.eq <- svydesign(ids=~cds, strata =~strind,  fpc=~Nh, data=strSRS.eq)
svystrSRS.pr <- svydesign(ids=~cds, strata =~strind,  fpc=~Nh, data=strSRS.pr)
svystrSRS.op <- svydesign(ids=~cds, strata =~strind,  fpc=~Nh, data=strSRS.op)
c( eq=SE(svymean(~api00, svystrSRS.eq))
,pr=SE(svymean(~api00, svystrSRS.pr))
,op=SE(svymean(~api00, svystrSRS.op))
)
set.seed(4367)
s.eq <- strSR.sample(POP$stype, nh.eq, replace=FALSE)
s.pr <- strSR.sample(POP$stype, nh.pr, replace=FALSE)
s.op <- strSR.sample(POP$stype, nh.op, replace=FALSE)
strSRS.eq <- POP[s.eq,]
strSRS.pr <- POP[s.pr,]
strSRS.op <- POP[s.op,]
#options(survey.lonely.psu="adjust")
svystrSRS.eq <- svydesign(ids=~cds, strata =~strind,  fpc=~Nh, data=strSRS.eq)
svystrSRS.pr <- svydesign(ids=~cds, strata =~strind,  fpc=~Nh, data=strSRS.pr)
svystrSRS.op <- svydesign(ids=~cds, strata =~strind,  fpc=~Nh, data=strSRS.op)
c( eq=SE(svymean(~api00, svystrSRS.eq))
,pr=SE(svymean(~api00, svystrSRS.pr))
,op=SE(svymean(~api00, svystrSRS.op))
)
set.seed(4356)
s.eq <- strSR.sample(POP$stype, nh.eq, replace=FALSE)
s.pr <- strSR.sample(POP$stype, nh.pr, replace=FALSE)
s.op <- strSR.sample(POP$stype, nh.op, replace=FALSE)
strSRS.eq <- POP[s.eq,]
strSRS.pr <- POP[s.pr,]
strSRS.op <- POP[s.op,]
#options(survey.lonely.psu="adjust")
svystrSRS.eq <- svydesign(ids=~cds, strata =~strind,  fpc=~Nh, data=strSRS.eq)
svystrSRS.pr <- svydesign(ids=~cds, strata =~strind,  fpc=~Nh, data=strSRS.pr)
svystrSRS.op <- svydesign(ids=~cds, strata =~strind,  fpc=~Nh, data=strSRS.op)
c( eq=SE(svymean(~api00, svystrSRS.eq))
,pr=SE(svymean(~api00, svystrSRS.pr))
,op=SE(svymean(~api00, svystrSRS.op))
)
nh.eq
nh.op
nh.op
nh.pr
c( eq=SE(svymean(~api00, svystrSRS.eq))
,pr=SE(svymean(~api00, svystrSRS.pr))
,op=SE(svymean(~api00, svystrSRS.op))
)
library(survey)
c( eq=SE(svymean(~api00, svystrSRS.eq))
,pr=SE(svymean(~api00, svystrSRS.pr))
,op=SE(svymean(~api00, svystrSRS.op))
)
library(survey)
library(sampling)
data(api)
POP <- apipop
POP$qapi99 <- cut(POP$api99, quantile(POP$api99), include.lowest = T)
POP$strind <- paste(POP$qapi99, POP$stype, sep = "_")
POP$Nh    <- table(POP$strind)[POP$strind]
Nh.tab  <- table(POP$stype)
Nh.vec  <- as.vector(Nh)
tab.names <- apply(expand.grid(dimnames(Nh.tab)),1,paste,collapse="_")
names(Nh.vec) <- tab.names
mosaicplot(Nh.tab)
#sample size
n <- 60 #ceiling(dim(POP)[1]*0.01)
##allocations
#equal
nh.eq <-  rep(n/length(Nh.tab),length(Nh.tab))
names(nh.eq) <- tab.names
#proportional
nh.pr <- round(Nh.tab/sum(Nh.vec)*n)
#optimal
V.h   <- tapply(POP$api99,POP$stype,sd)[tab.names]
nh.op <- round((Nh.tab*V.h)/(sum(Nh.tab*V.h))*n)
##select sample
strSR.sample <- function(strind, nh, replace=FALSE){
Nh   <- table(strind)[names(nh)]
h.id <- split(1:sum(Nh), strind)[names(nh)]
sam <- mapply(function(x,y) sample(x, y, replace=replace), Nh, nh, SIMPLIFY = F)
sam <- unlist(mapply(function(x,y) x[y]
, h.id
, sam, SIMPLIFY = F))
sam
}
set.seed(4356)
s.eq <- strSR.sample(POP$stype, nh.eq, replace=FALSE)
s.pr <- strSR.sample(POP$stype, nh.pr, replace=FALSE)
s.op <- strSR.sample(POP$stype, nh.op, replace=FALSE)
strSRS.eq <- POP[s.eq,]
strSRS.pr <- POP[s.pr,]
strSRS.op <- POP[s.op,]
#options(survey.lonely.psu="adjust")
svystrSRS.eq <- svydesign(ids=~cds, strata =~strind,  fpc=~Nh, data=strSRS.eq)
svystrSRS.pr <- svydesign(ids=~cds, strata =~strind,  fpc=~Nh, data=strSRS.pr)
svystrSRS.op <- svydesign(ids=~cds, strata =~strind,  fpc=~Nh, data=strSRS.op)
c( eq=SE(svymean(~api00, svystrSRS.eq))
,pr=SE(svymean(~api00, svystrSRS.pr))
,op=SE(svymean(~api00, svystrSRS.op))
)
SE(svymean(~api00, svystrSRS.eq))
SE(svymean(~api00, svystrSRS.pr))
SE(svymean(~api00, svystrSRS.op))
table(POP$strind)[POP$strind]
POP <- apipop
POP$qapi99 <- cut(POP$api99, quantile(POP$api99), include.lowest = T)
POP$Nh    <- table(POP$strind)[POP$stype]
Nh.tab  <- table(POP$stype)
Nh.vec  <- as.vector(Nh)
tab.names <- apply(expand.grid(dimnames(Nh.tab)),1,paste,collapse="_")
names(Nh.vec) <- tab.names
mosaicplot(Nh.tab)
#sample size
n <- 60 #ceiling(dim(POP)[1]*0.01)
##allocations
#equal
nh.eq <-  rep(n/length(Nh.tab),length(Nh.tab))
names(nh.eq) <- tab.names
#proportional
nh.pr <- round(Nh.tab/sum(Nh.vec)*n)
#optimal
V.h   <- tapply(POP$api99,POP$stype,sd)[tab.names]
nh.op <- round((Nh.tab*V.h)/(sum(Nh.tab*V.h))*n)
##select sample
strSR.sample <- function(strind, nh, replace=FALSE){
Nh   <- table(strind)[names(nh)]
h.id <- split(1:sum(Nh), strind)[names(nh)]
sam <- mapply(function(x,y) sample(x, y, replace=replace), Nh, nh, SIMPLIFY = F)
sam <- unlist(mapply(function(x,y) x[y]
, h.id
, sam, SIMPLIFY = F))
sam
}
s.eq <- strSR.sample(POP$stype, nh.eq, replace=FALSE)
s.pr <- strSR.sample(POP$stype, nh.pr, replace=FALSE)
s.op <- strSR.sample(POP$stype, nh.op, replace=FALSE)
strSRS.eq <- POP[s.eq,]
strSRS.pr <- POP[s.pr,]
strSRS.op <- POP[s.op,]
table(strSRS.op$stype)
table(strSRS.pr$stype)
svystrSRS.eq <- svydesign(ids=~cds, strata =~stype,  fpc=~Nh, data=strSRS.eq)
svystrSRS.pr <- svydesign(ids=~cds, strata =~stype,  fpc=~Nh, data=strSRS.pr)
svystrSRS.op <- svydesign(ids=~cds, strata =~stype,  fpc=~Nh, data=strSRS.op)
c( eq=SE(svymean(~api00, svystrSRS.eq))
,pr=SE(svymean(~api00, svystrSRS.pr))
,op=SE(svymean(~api00, svystrSRS.op))
)
strSRS.eq$Nh
POP <- apipop
POP$qapi99 <- cut(POP$api99, quantile(POP$api99), include.lowest = T)
POP$Nh    <- table(POP$stype)[POP$stype]
Nh.tab  <- table(POP$stype)
Nh.vec  <- as.vector(Nh)
tab.names <- apply(expand.grid(dimnames(Nh.tab)),1,paste,collapse="_")
names(Nh.vec) <- tab.names
mosaicplot(Nh.tab)
#sample size
n <- 60 #ceiling(dim(POP)[1]*0.01)
##allocations
#equal
nh.eq <-  rep(n/length(Nh.tab),length(Nh.tab))
names(nh.eq) <- tab.names
#proportional
nh.pr <- round(Nh.tab/sum(Nh.vec)*n)
#optimal
V.h   <- tapply(POP$api99,POP$stype,sd)[tab.names]
nh.op <- round((Nh.tab*V.h)/(sum(Nh.tab*V.h))*n)
##select sample
strSR.sample <- function(strind, nh, replace=FALSE){
Nh   <- table(strind)[names(nh)]
h.id <- split(1:sum(Nh), strind)[names(nh)]
sam <- mapply(function(x,y) sample(x, y, replace=replace), Nh, nh, SIMPLIFY = F)
sam <- unlist(mapply(function(x,y) x[y]
, h.id
, sam, SIMPLIFY = F))
sam
}
R <- 2000
set.seed(4356)
s.eq <- strSR.sample(POP$stype, nh.eq, replace=FALSE)
s.pr <- strSR.sample(POP$stype, nh.pr, replace=FALSE)
s.op <- strSR.sample(POP$stype, nh.op, replace=FALSE)
strSRS.eq <- POP[s.eq,]
strSRS.pr <- POP[s.pr,]
strSRS.op <- POP[s.op,]
#options(survey.lonely.psu="adjust")
svystrSRS.eq <- svydesign(ids=~cds, strata =~stype,  fpc=~Nh, data=strSRS.eq)
svystrSRS.pr <- svydesign(ids=~cds, strata =~stype,  fpc=~Nh, data=strSRS.pr)
svystrSRS.op <- svydesign(ids=~cds, strata =~stype,  fpc=~Nh, data=strSRS.op)
c( eq=SE(svymean(~api00, svystrSRS.eq))
,pr=SE(svymean(~api00, svystrSRS.pr))
,op=SE(svymean(~api00, svystrSRS.op))
)
set.seed(4356)
s.eq <- strSR.sample(POP$stype, nh.eq, replace=FALSE)
s.pr <- strSR.sample(POP$stype, nh.pr, replace=FALSE)
s.op <- strSR.sample(POP$stype, nh.op, replace=FALSE)
strSRS.eq <- POP[s.eq,]
strSRS.pr <- POP[s.pr,]
strSRS.op <- POP[s.op,]
#options(survey.lonely.psu="adjust")
svystrSRS.eq <- svydesign(ids=~cds, strata =~stype,  fpc=~Nh, data=strSRS.eq)
svystrSRS.pr <- svydesign(ids=~cds, strata =~stype,  fpc=~Nh, data=strSRS.pr)
svystrSRS.op <- svydesign(ids=~cds, strata =~stype,  fpc=~Nh, data=strSRS.op)
c( eq=SE(svymean(~api00, svystrSRS.eq))
,pr=SE(svymean(~api00, svystrSRS.pr))
,op=SE(svymean(~api00, svystrSRS.op))
)
svymean(~api00, svystrSRS.eq)
svymean(~api00, svystrSRS.pr)
svymean(~api00, svystrSRS.op)
set.seed(2345)
s.eq <- strSR.sample(POP$stype, nh.eq, replace=FALSE)
s.pr <- strSR.sample(POP$stype, nh.pr, replace=FALSE)
s.op <- strSR.sample(POP$stype, nh.op, replace=FALSE)
strSRS.eq <- POP[s.eq,]
strSRS.pr <- POP[s.pr,]
strSRS.op <- POP[s.op,]
#options(survey.lonely.psu="adjust")
svystrSRS.eq <- svydesign(ids=~cds, strata =~stype,  fpc=~Nh, data=strSRS.eq)
svystrSRS.pr <- svydesign(ids=~cds, strata =~stype,  fpc=~Nh, data=strSRS.pr)
svystrSRS.op <- svydesign(ids=~cds, strata =~stype,  fpc=~Nh, data=strSRS.op)
c( eq=SE(svymean(~api00, svystrSRS.eq))
,pr=SE(svymean(~api00, svystrSRS.pr))
,op=SE(svymean(~api00, svystrSRS.op))
)
set.seed(1133)
s.eq <- strSR.sample(POP$stype, nh.eq, replace=FALSE)
s.pr <- strSR.sample(POP$stype, nh.pr, replace=FALSE)
s.op <- strSR.sample(POP$stype, nh.op, replace=FALSE)
strSRS.eq <- POP[s.eq,]
strSRS.pr <- POP[s.pr,]
strSRS.op <- POP[s.op,]
#options(survey.lonely.psu="adjust")
svystrSRS.eq <- svydesign(ids=~cds, strata =~stype,  fpc=~Nh, data=strSRS.eq)
svystrSRS.pr <- svydesign(ids=~cds, strata =~stype,  fpc=~Nh, data=strSRS.pr)
svystrSRS.op <- svydesign(ids=~cds, strata =~stype,  fpc=~Nh, data=strSRS.op)
c( eq=SE(svymean(~api00, svystrSRS.eq))
,pr=SE(svymean(~api00, svystrSRS.pr))
,op=SE(svymean(~api00, svystrSRS.op))
)
rm(list=ls())
source('~/.active-rstudio-document', echo=TRUE)
)
data(api)
MarginTab  <- table(apipop[,c("stype","sch.wide")])
MarginTab. <- cbind(MarginTab, SUM=rowSums(MarginTab))
MarginTab. <- rbind(MarginTab.,SUM=colSums(MarginTab.))
xtab <- xtable(MarginTab.,digits = 0
,caption = "Population Counts $\\tau_{x_q}$ for School Type (\\texttt{stype}) and School Target (\\texttt{sch.wide}) ")
align(xtab)<- "l|rr|r"
library(PracTools) #load the package
data(smho.N874)    #load the data set
head(smho.N874)
smho <- smho.N874[smho.N874$hosp.type != 4, ]
pairs.chrt <-
ggpairs(smho,columns = which(colnames(smho)%in%c("EXPTOTAL","BEDS","SEENCNT","EOYCNT"))) +
theme(legend.position = "none",
panel.grid.major = element_blank(),
axis.ticks = element_blank(),
axis.title.x = element_text(angle = 90, vjust = 1, color = "black"),
panel.border = element_rect(fill = NA),
axis.text.x =element_text(size=8,angle = 90) )
print(pairs.chrt, left = 0.5, bottom = 0.35)
smho. <- smho
smho.$hosp.type <- as.factor(smho.$hosp.type)
smho.$FINDIRCT  <- as.factor(smho.$FINDIRCT)
lmod1 <- lm(EXPTOTAL ~ SEENCNT + EOYCNT + FINDIRCT + hosp.type:BEDS, data=smho.)
tab.model <- xtable(summary(lmod1),digits = 2,caption = "Model Summary")
print(tab.model,caption.placement = "top")
smho. <-   # before sampling order the data set by hospital type
smho.[order(smho.$hosp.type),]
x <- smho.[,"BEDS"]
x[x <= 5] <- 5      # recode small hospitals to have a minimum size
x <- sqrt(x)
n <- 80             #sample size
IP  <- n*x/sum(x)
set.seed(428274453)
sam <- UPsystematic(IP)
sam.dat <- smho.[sam==1, ]
sam.dat$d <- 1/IP[sam==1] #the design weight
sam.dsgn <-
svydesign(ids = ~1,               # no clusters
strata = NULL,          # no strata
data = sam.dat,         # the sample data
weights = ~d)           # the design weight
#the model we use for the GREG
lmod2 <- lm(EXPTOTAL ~ SEENCNT + EOYCNT + hosp.type:BEDS, data=smho.)
#2. compute pop totals of auxiliaries
pop.tots <- colSums(model.matrix(lmod2)) #Inefficient but convenient!
#3. use 'calibrate' to compute the new weights
sam.cal <-
calibrate(design = sam.dsgn,
formula = ~ SEENCNT + EOYCNT + hosp.type:BEDS,
population = pop.tots,
calfun='linear' )
svytotal(~SEENCNT+EOYCNT, sam.cal)
?smho.N874
svyby(~EXPTOTAL, by=~hosp.type, design=sam.cal, FUN=svytotal)
set.seed(428274453)
sam <- UPsystematic(IP)
sam.dat <- smho.[sam==1, ]
sam.dat$IP <- IP[sam==1]   #the design weight
sam.dsgn <-
svydesign(ids = ~1         # no clusters
,data = sam.dat   # the sample data
,fpc = ~IP        # incl. prob
,pps= "brewer"    # variance approx. method
,variance="YG")   # Variance est. type
sam.dsgn <-
svydesign( ids = ~1         # no clusters
,data = sam.dat   # the sample data
,fpc = ~IP        # incl. prob
,pps= "brewer")    # variance approx. method
lmod2 <- lm(EXPTOTAL ~ SEENCNT + EOYCNT + hosp.type:BEDS, data=smho.)
pop.tots <- colSums(model.matrix(lmod2)) #Inefficient but convenient!
sam.cal <-
calibrate(design = sam.dsgn,
formula = ~ SEENCNT + EOYCNT + hosp.type:BEDS,
population = pop.tots,
calfun='linear' )
e
svyby(~BEDS, by=~hosp.type, design=sam.cal, FUN=svytotal)
svytotal(~SEENCNT+EOYCNT, sam.cal)
pop.tots
svytotal(~EXPTOTAL, sam.cal)
svytotal(~EXPTOTAL, sam.dsgn)
SE(svytotal(~EXPTOTAL, sam.cal))
SE(svytotal(~EXPTOTAL, sam.dsgn))
svytotal(~EXPTOTAL, sam.cal)/svytotal(~EXPTOTAL, sam.dsgn)
svyby(~EXPTOTAL, by=~hosp.type, design=sam.cal, FUN=svytotal)
svyby(~EXPTOTAL, by=~hosp.type, design=sam.dsgn, FUN=svytotal)
pop.tots
tapply(smho.$BEDS,smho.$hosp.type,sum)
table(smho.$hosp.type)
svytotal(~EXPTOTAL, sam.dsgn)
svytotal(~EXPTOTAL, sam.cal)
ori.opt <- options()
options( scipen = 5, digits = 6 )
svytotal(~EXPTOTAL, sam.dsgn)
svytotal(~EXPTOTAL, sam.cal)
options( scipen = 2, digits = 6 )
svytotal(~EXPTOTAL, sam.dsgn)
svytotal(~EXPTOTAL, sam.cal)
options( scipen = 2, digits = 3 )
svytotal(~EXPTOTAL, sam.dsgn)
svytotal(~EXPTOTAL, sam.cal)
options( scipen = 0, digits = 2 )
svytotal(~EXPTOTAL, sam.dsgn)
svytotal(~EXPTOTAL, sam.cal)
options( scipen = 1, digits = 2 )
svytotal(~EXPTOTAL, sam.dsgn)
svytotal(~EXPTOTAL, sam.cal)
options( scipen = 0, digits = 5 )
svytotal(~EXPTOTAL, sam.dsgn)
svytotal(~EXPTOTAL, sam.cal)
options( scipen = 0)
svytotal(~EXPTOTAL, sam.dsgn)
svytotal(~EXPTOTAL, sam.cal)
options( scipen = -1)
svytotal(~EXPTOTAL, sam.dsgn)
svytotal(~EXPTOTAL, sam.cal)
var(svytotal(~EXPTOTAL, sam.dsgn))
SEr(svytotal(~EXPTOTAL, sam.dsgn))
SE(svytotal(~EXPTOTAL, sam.dsgn))
SE(svytotal(~EXPTOTAL, sam.dsgn))^2
vcov(svytotal(~EXPTOTAL, sam.dsgn))
vcov(svytotal(~EXPTOTAL, sam.dsgn))/vcov(svytotal(~EXPTOTAL, sam.cal))
SE(svytotal(~EXPTOTAL, sam.dsgn))/SE(svytotal(~EXPTOTAL, sam.cal))
181.66+51.67
url <- "https://raw.githubusercontent.com/BernStZi/SamplingAndEstimation/short/tutorial/Samples_for_EX3b.R"
source(url)
url <- "https://raw.githubusercontent.com/BernStZi/SamplingAndEstimation/short/tutorial/Samples_for_EX3b.R"
source(url)
library(sampling)
library(survey)
# path <- "F:/ESS Data/"
# setwd(path)
data(belgianmunicipalities)
bm <- belgianmunicipalities
bm <- bm[-499,] # Delete that entry, because it is too small
bm2 <- bm # for the clustersample
l <- 80
nh <- 300
### income ###
income <- by(bm, bm$INS, function(x)rnorm(x$Tot04, mean=x$averageincome,sd=sqrt(x$averageincome)))
### first stage inclusion probability ####
bm$nu <- bm$Tot03/sum(bm$Tot03)*l
bm$pro <- bm$nu%%1
bm$p <- floor(bm$nu)
bm$prob1 <- bm$nu
bm$prob1[bm$prob1>1] <- 1
set.seed(42)
cs <- UPmaxentropy(bm$pro)
bm$cs <- cs
clus <- bm[cs==1|bm$p>0,]
clus$p <- clus$p+clus$cs
### income to sample ###
nh1 <- nh*clus$p
clus$nh1 <- nh1
clus.inc <- income[as.character(clus$INS)]
inc.samp <- mapply(function(x,y)sample(x,y),clus.inc,nh1)
names(inc.samp) <- names(clus.inc)
### unlist and merge ###
INS <- rep(names(inc.samp),times=sapply(inc.samp,length))
data.inc <- data.frame(inc = unlist(inc.samp), INS = INS)
Data.be <- merge(clus,data.inc,by="INS", all.x=TRUE)
### inclusion probability: second stage ####
Data.be$id <- 1:nrow(Data.be)
## Probability of inclusion second sampling stage
Data.be$prob2 <- Data.be$nh1/Data.be$Tot03
Data.be$prob2[Data.be$nu>1] <- Data.be$prob2[Data.be$nu>1]*Data.be$nu[Data.be$nu>1]/(Data.be$p[Data.be$nu>1])
###
### Cluster Sample for belgianmunicipalities
# Number of clusters
l2 <- 10
# Probability of inclusion
bm2$prob1 <-  bm2$Tot03/sum(bm2$Tot03)*l2
set.seed(42)
#Sampling clusters
cs2 <- UPmaxentropy(bm2$prob1)
clus2 <- bm2[cs2==1,]
## Merging
clus.inc2 <- income[as.character(clus2$INS)]
INS <- rep(names(clus.inc2),times=sapply(clus.inc2,length))
data.inc2 <- data.frame(inc = unlist(clus.inc2), INS = INS)
Data.be2 <- merge(clus2,data.inc2,by="INS", all.x=TRUE)
### population size
Data.be2$N <- sum(bm2$Tot03)
url <- "https://raw.githubusercontent.com/BernStZi/SamplingAndEstimation/short/tutorial/Samples_for_EX3b.R"
source(url)
url <- "https://raw.githubusercontent.com/BernStZi/SamplingAndEstimation/short/tutorial/Samples_for_EX3b.R"
source(url)
url <- "https://raw.githubusercontent.com/BernStZi/SamplingAndEstimation/short/tutorial/Samples_for_EX3b.R"
source(url)
>>>>>>> bc2abe730c52f404eb97891ae74c36be0ab31d00
